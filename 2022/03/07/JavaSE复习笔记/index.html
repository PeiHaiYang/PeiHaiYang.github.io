<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 红尘泪思颜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JavaSE复习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/03/07/JavaSE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-03-07T15:38:58.541Z" itemprop="datePublished">2022-03-07</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">15.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">62 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>第九章常用核心类</p>
<h2 id="一、String类"><a href="#一、String类" class="headerlink" title="一、String类"></a>一、String类</h2><h2 id="主要看一下String的底层原理"><a href="#主要看一下String的底层原理" class="headerlink" title="主要看一下String的底层原理"></a>主要看一下String的底层原理</h2><p>​    String是用于表示一个字符序列的，可以使用字符串字面量，比如“abc”，来表示一个String类的实例。</p>
<h3 id="1-String的特点"><a href="#1-String的特点" class="headerlink" title="1.String的特点"></a>1.String的特点</h3><ul>
<li>字符串一旦创建不可变，是个常量</li>
<li>底层使用private修饰的char数组来存储字符序列，JDK9之后使用byte数组</li>
<li>String类是final修饰的，不能被继承，它的方法不能被重写。    </li>
<li>字符串字面量存储在字符串常量池中，并且相同的字符串只有一份</li>
</ul>
<h3 id="2-字符串对象的创建方式"><a href="#2-字符串对象的创建方式" class="headerlink" title="2.字符串对象的创建方式"></a>2.字符串对象的创建方式</h3><ul>
<li>使用字符串字面量直接创建</li>
</ul>
<ul>
<li><code>public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li>
<li><code> String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li>
<li><code>public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li>
<li><code>public String(byte[] bytes) </code> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</li>
<li><code>public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li>
<li>使用连接符+拼接字符串，字符串跟任意类型拼接结果都为字符串</li>
</ul>
<h3 id="3-String类的常用方法"><a href="#3-String类的常用方法" class="headerlink" title="3.String类的常用方法"></a>3.String类的常用方法</h3><ul>
<li>基本方法</li>
</ul>
<p>（1）boolean isEmpty()：字符串是否为空</p>
<p>（2）int length()：返回字符串的长度</p>
<p>（3）String concat(xx)：拼接，等价于+</p>
<p>（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写</p>
<p>（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写</p>
<p>（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小</p>
<p>（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</p>
<p>（8）String toLowerCase()：将字符串中大写字母转为小写</p>
<p>（9）String toUpperCase()：将字符串中小写字母转为大写</p>
<p>（10）String trim()：去掉字符串前后空白符</p>
<ul>
<li>查找相关</li>
</ul>
<p>（11）boolean contains(xx)：是否包含xx</p>
<p>（12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1</p>
<p>（13）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1</p>
<ul>
<li>截取相关</li>
</ul>
<p>（14）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </p>
<p>（15）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 </p>
<ul>
<li>字符相关</li>
</ul>
<p>（16）char charAt(index)：返回[index]位置的字符</p>
<p>（17）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回</p>
<p>（18）String(char[] value)：返回指定数组中表示该字符序列的 String。 </p>
<p>（19）String(char[] value, int offset, int count)：返回指定数组中表示该字符序列的 String。</p>
<p>（20）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String</p>
<p>（21）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</p>
<p>（22）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String</p>
<p>（23）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String</p>
<ul>
<li>编码相关</li>
</ul>
<p>（24）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码进行编码</p>
<p>​            byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码</p>
<p>（25）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码</p>
<p>​           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码</p>
<ul>
<li>其他</li>
</ul>
<p>（26）boolean startsWith(xx)：是否以xx开头</p>
<p>（27）boolean endsWith(xx)：是否以xx结尾</p>
<p>（28）boolean matchs(正则表达式)：判断当前字符串是否匹配某个正则表达式</p>
<p>（29）String replace(xx,xx)：不支持正则</p>
<p>（30）String replaceFirst(正则，value)：替换第一个匹配部分</p>
<p>（31）String repalceAll(正则， value)：替换所有匹配部分</p>
<p>（32）String[] split(正则)：按照某种规则进行拆分</p>
<h3 id="4-内存分析"><a href="#4-内存分析" class="headerlink" title="4.内存分析"></a>4.内存分析</h3><ul>
<li>new出来的对象都是在对象新开辟内存空间  new String();</li>
<li>字符串变量与任意类型通过+拼接，结果在堆中。String s1&#x3D;”abc”,s2&#x3D;”efg”; String s3&#x3D;s1+s2; 有变量就会是堆空间</li>
<li>字符串字面量都是在常量池中,String s&#x3D;”abc”+”hello”;</li>
<li>intern():把堆中的字符串写入常量池，不同的JDK版本，有区别</li>
</ul>
<h2 id="二、可变字符串序列"><a href="#二、可变字符串序列" class="headerlink" title="二、可变字符串序列"></a>二、可变字符串序列</h2><p>StringBuffer和StringBuilder用于表示一个可变长的字符序列</p>
<p><strong>StringBuffer：</strong>老的，线程安全的（因为它的方法有synchronized修饰），效率低</p>
<p><strong>StringBuilder：</strong>线程不安全的，效率高</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>常用的API，StringBuilder、StringBuffer的API是完全一致的</p>
<p>​        new StringBuilder();</p>
<p>​        new StringBuilder(String  s);</p>
<p><strong>（1）StringBuffer append(xx)：拼接，追加</strong></p>
<p>（2）StringBuffer insert(int index, xx)：在[index]位置插入xx</p>
<p>（3）StringBuffer delete(int start, int end)：删除[start,end)之间字符</p>
<p>StringBuffer deleteCharAt(int index)：删除[index]位置字符</p>
<p>（4）void setCharAt(int index, xx)：替换[index]位置字符</p>
<p>（5）StringBuffer reverse()：反转</p>
<p>（6）void setLength(int newLength) ：设置当前字符序列长度为newLength</p>
<p>（7）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str</p>
<p>（8）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标</p>
<p>​          int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标</p>
<p>​         int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标</p>
<p>​         int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标</p>
<p>（9）String substring(int start)：截取当前字符序列[start,最后]</p>
<p>（10）String substring(int start, int end)：截取当前字符序列[start,end)</p>
<p><strong>（11）String toString()：返回此序列中数据的字符串表示形式</strong></p>
<h2 id="三、Math类"><a href="#三、Math类" class="headerlink" title="三、Math类"></a>三、Math类</h2><ul>
<li>public static final double PI：返回圆周率</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double abs(double a) </code> ：返回 double 值的绝对值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(-<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">d1</span> <span class="operator">=</span> Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d2</span> <span class="operator">=</span> Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>public static double pow(double a,double b)：返回a的b幂次方法</li>
<li>public static double sqrt(double a)：返回a的平方根</li>
<li>public static double random()：返回[0,1)的随机值</li>
<li>public static double max(double x, double y)：返回x,y中的最大值</li>
<li>public static double min(double x, double y)：返回x,y中的最小值</li>
</ul>
<h2 id="四、Random类"><a href="#四、Random类" class="headerlink" title="四、Random类"></a>四、Random类</h2><p>用于产生随机数</p>
<ul>
<li>**public Random():**创建一个新的随机数生成器。此构造方法将随机数生成器的种子设置为某个值，该值与此构造方法的所有其他调用所用的值完全不同。(没有真正的随机数，需要种子产生随机数，同一个种子产生的伪随机数序列相同)</li>
<li>public Random(long seed):使用单个 long 种子创建一个新的随机数生成器。该种子是伪随机数生成器的内部状态的初始值，该生成器可通过方法 next(int) 维护。</li>
</ul>
<ul>
<li><p>boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </p>
</li>
<li><p>void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。 </p>
</li>
<li><p>double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </p>
</li>
<li><p>float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </p>
</li>
<li><p>double nextGaussian():返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </p>
</li>
<li><p>int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </p>
</li>
<li><p>**int nextInt(int n):**返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 【0，n)</p>
</li>
<li><p>long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</p>
</li>
</ul>
<h2 id="五、BigInteger"><a href="#五、BigInteger" class="headerlink" title="五、BigInteger"></a>五、BigInteger</h2><p>表示一个超大的精确的整数</p>
<ul>
<li>BigInteger(String val) </li>
<li>BigInteger add(BigInteger val)  </li>
<li>BigInteger subtract(BigInteger val)</li>
<li>BigInteger multiply(BigInteger val) </li>
<li>BigInteger divide(BigInteger val) </li>
<li>BigInteger remainder(BigInteger val)</li>
<li>int intValue():将此 BigInteger 转换为 int。 </li>
<li>long longValue():将此 BigInteger 转换为 long。 </li>
<li>float floatValue():将此 BigInteger 转换为 float。</li>
</ul>
<h2 id="六、BigDecimal"><a href="#六、BigDecimal" class="headerlink" title="六、BigDecimal"></a>六、BigDecimal</h2><p>表示一个任意精度的超大小数</p>
<ul>
<li>BigDecimal(String val) </li>
<li>BigDecimal add(BigDecimal val) </li>
<li>BigDecimal subtract(BigDecimal val)</li>
<li>BigDecimal multiply(BigDecimal val) </li>
<li>BigDecimal divide(BigDecimal val) </li>
<li>BigDecimal divide(BigDecimal divisor, int roundingMode) </li>
<li>BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) </li>
<li>BigDecimal remainder(BigDecimal val) </li>
<li>double doubleValue():将此 BigDecimal 转换为 double。</li>
</ul>
<h2 id="七、系统相关类"><a href="#七、系统相关类" class="headerlink" title="七、系统相关类"></a>七、系统相关类</h2><h3 id="1-System类"><a href="#1-System类" class="headerlink" title="1.System类"></a>1.System类</h3><p>​    封装了系统相关的信息</p>
<ul>
<li><p>static long currentTimeMillis() ：返回当前系统时间距离1970-1-1 0:0:0的毫秒值</p>
</li>
<li><p>static void exit(int status) ：退出当前系统</p>
</li>
<li><p>static void gc() ：运行垃圾回收器。</p>
</li>
<li><p>static String getProperty(String key)：获取某个系统属性</p>
</li>
</ul>
<h3 id="2-Runtime类"><a href="#2-Runtime类" class="headerlink" title="2.Runtime类"></a>2.Runtime类</h3><ul>
<li><p>程序运行时类，封装程序运行期间系统环境相关的信息</p>
<p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。可以通过  <code>getRuntime</code> 方法获取当前运行时。  应用程序不能创建自己的 Runtime 类实例。</p>
<p>public static Runtime getRuntime()： 返回与当前 Java 应用程序相关的运行时对象。</p>
<p>public long totalMemory()：返回 Java 虚拟机中的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。</p>
<p>public long freeMemory()：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<p>public long maxMemory():   返回 Java 虚拟机试图使用的最大内存量。 </p>
<p>Process exec(String command):在单独的进程中执行指定的字符串命令。</p>
</li>
</ul>
<h2 id="八、相关日期类"><a href="#八、相关日期类" class="headerlink" title="八、相关日期类"></a>八、相关日期类</h2><h3 id="1-Date类"><a href="#1-Date类" class="headerlink" title="1.Date类"></a>1.Date类</h3><ul>
<li><p>构造器</p>
<p>Date();</p>
<p>Date(long time);</p>
</li>
<li><p>常用方法</p>
<p>long getTime();&#x2F;&#x2F;获取1970.1.1到现在的毫秒值</p>
</li>
</ul>
<h3 id="2-Calendar日历类"><a href="#2-Calendar日历类" class="headerlink" title="2.Calendar日历类"></a>2.Calendar日历类</h3><ul>
<li><p>常用方法</p>
<p>static Calendar getInstance();&#x2F;&#x2F;获取当前类的一个实例</p>
<p>get(int n);&#x2F;&#x2F;参数为静态常量，比如Calendar.YEAR</p>
</li>
</ul>
<h3 id="3-SimpleDateFormat日期格式类"><a href="#3-SimpleDateFormat日期格式类" class="headerlink" title="3.SimpleDateFormat日期格式类"></a>3.SimpleDateFormat日期格式类</h3><p>​    用于把日期格式化为字符串，或把字符串解析为日期对象，可以自定义格式。</p>
<p>​    示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建格式化类对象</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化操作，把日期对象格式化为字符串表示的日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> sdf.**format**(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串表示的日期，解析为日期对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(strDate);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="4-JDK8后的日期类"><a href="#4-JDK8后的日期类" class="headerlink" title="4. JDK8后的日期类"></a>4. JDK8后的日期类</h3><ul>
<li><p>LocalDate、LocalTime、LocalDateTime</p>
<ul>
<li><table>
<thead>
<tr>
<th>方法</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>now() &#x2F; now(ZoneId zone)</strong></td>
<td>静态方法，根据当前时间创建对象&#x2F;指定时区的对象</td>
</tr>
<tr>
<td><strong>of()</strong></td>
<td>静态方法，根据指定日期&#x2F;时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth()&#x2F;getDayOfYear()</td>
<td>获得月份天数(1-31) &#x2F;获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td>getMonthValue() &#x2F; getYear()</td>
<td>获得月份(1-12) &#x2F;获得年份</td>
</tr>
<tr>
<td>getHours()&#x2F;getMinute()&#x2F;getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()&#x2F;withDayOfYear()&#x2F;withMonth()&#x2F;withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>with(TemporalAdjuster  t)</td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths() &#x2F; minusWeeks()&#x2F;minusDays()&#x2F;minusYears()&#x2F;minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
<tr>
<td>plus(TemporalAmount t)&#x2F;minus(TemporalAmount t)</td>
<td>添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td>isBefore()&#x2F;isAfter()</td>
<td>比较两个 LocalDate</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否是闰年（在LocalDate类中声明）</td>
</tr>
<tr>
<td><strong>format(DateTimeFormatter  t)</strong></td>
<td>格式化本地日期、时间，返回一个字符串</td>
</tr>
<tr>
<td><strong>parse(Charsequence text)</strong></td>
<td>静态方法，将指定格式的字符串解析为日期、时间</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>​        -</p>
<ul>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1999</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Period和Duration类，表示两个日期或时间直接的间隔</p>
</li>
<li><p>DateTimeFormatter日期时间格式类</p>
<ul>
<li>自定义格式：<code>DateTimeFormatter.ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">	<span class="comment">//自定义的格式</span></span><br><span class="line">	<span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">     <span class="comment">//格式化操作</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(now);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串解析为日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//自定义的格式</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line">    <span class="comment">//解析操作</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2020.12.12&quot;</span>, pattern);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="九、数组工具类Arrays"><a href="#九、数组工具类Arrays" class="headerlink" title="九、数组工具类Arrays"></a>九、数组工具类Arrays</h2><p>下只列出int[]类型的，其他类型的数组类推：</p>
<ul>
<li><p>static int binarySearch(int[] a, int key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数</p>
</li>
<li><p>static int[] copyOf(int[] original, int newLength)  ：根据original原数组复制一个长度为newLength的新数组，并返回新数组</p>
</li>
<li><p>static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组</p>
</li>
<li><p>static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同</p>
</li>
<li><p>static void fill(int[] a, int val) ：用val填充整个a数组</p>
</li>
<li><p>static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val </p>
</li>
<li><p>static void sort(int[] a) ：将a数组按照从小到大进行排序</p>
</li>
<li><p>static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列</p>
</li>
<li><p>static String toString(int[] a) ：把a数组的元素，拼接为一个字符串，形式为：[元素1，元素2，元素3。。。]</p>
</li>
</ul>
<h1 id="数组的算法升华"><a href="#数组的算法升华" class="headerlink" title="数组的算法升华"></a>数组的算法升华</h1><ol>
<li>数组的反转：把数组中元素首尾倒置、<ol>
<li>借助新数组</li>
<li>本数组内实现反转</li>
</ol>
</li>
<li>数组的扩容：数组一旦创建长度不可变，如果要扩容，本质是创建新的数组</li>
<li>数组元素的插入：在指定位置插入新元素<ol>
<li>先扩容：把插入位置之后的每个元素后移一位，以保证原数据的有序性。</li>
<li>插入新元素</li>
</ol>
</li>
<li>数组元素的删除：删除指定位置的元素，把后续的每个元素前移一位，保证元素连续性。</li>
<li>二分查找或折半查找：猜1-100之间数字游戏，前提元素是有序的。</li>
<li>直接选择排序原理：每轮找到最小的元素，跟第一个位置交换，确定第一个位置的元素，依次处理后续元素。</li>
</ol>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>设计模式就是前人在开发一些项目需求时，总结的一套经验，比如希望内存中只有一个类的实例。这就是单例模式。</p>
<p><strong>1.懒汉式</strong></p>
<p>有线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有的静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的公共的方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//第一次调用时创建对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 饿汉式</strong></p>
<p>比如Runtime类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//3.创建一个静态属性，赋值一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//只在类加载过程中执行一次，创建一个对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.提供公共的静态的方法返回一个此类的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> student;<span class="comment">//每次调用返回同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第十章-集合"><a href="#第十章-集合" class="headerlink" title="第十章 集合"></a>第十章 集合</h1><ol>
<li><p>概念：集合是一个数据容器，跟数组类似</p>
</li>
<li><p>区别数组：</p>
</li>
</ol>
<ul>
<li>数组的长度不可变，集合长度可变</li>
<li>数组存储的元素特点比较单一，只能是有序的，可以重复的，各种集合提供了不同存储特点</li>
<li>数组提供的功能单一，集合提供更丰富的功能用于对数据进行增删改查等操作。</li>
<li>数组可以存储基本数据类型和引用数据类型，集合只能存储引用数据类型。</li>
</ul>
<ol start="3">
<li>集合框架体系</li>
</ol>
<ul>
<li>Collection:接口，存储一组单个的元素</li>
</ul>
<p>​            List：元素有序的，可以重复的，并且有索引</p>
<p>​                    ArrayList：</p>
<p>​            Set：</p>
<ul>
<li>Map:接口，存储一组成对的元素（键值对）</li>
</ul>
<h2 id="一、Collection接口"><a href="#一、Collection接口" class="headerlink" title="一、Collection接口"></a>一、Collection接口</h2><p><strong>1、添加元素</strong></p>
<p>（1）add(E obj)：添加元素对象到当前集合中</p>
<p>（2）addAll(Collection&lt;? extends E&gt; other)：添加other集合中的所有元素对象到当前集合中，即this &#x3D; this ∪ other</p>
<p><strong>2、删除元素</strong></p>
<p> （1） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。</p>
<p> （2）boolean removeAll(Collection&lt;?&gt; coll)：从当前集合中删除所有与coll集合中相同的元素。即this &#x3D; this - this ∩ coll</p>
<p><strong>3、判断</strong></p>
<p>（1）boolean isEmpty()：判断当前集合是否为空集合。</p>
<p>（2）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素。</p>
<p>（3）boolean containsAll(Collection&lt;?&gt; c)：判断c集合中的元素是否在当前集合中都存在。即c集合是否是当前集合的“子集”。</p>
<p><strong>4、获取元素个数</strong></p>
<p>（1）int size()：获取当前集合中实际存储的元素个数</p>
<p><strong>5、交集</strong></p>
<p>（1）boolean retainAll(Collection&lt;?&gt; coll)：当前集合仅保留与c集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  &#x3D; this ∩ coll；</p>
<p><strong>6、转为数组</strong></p>
<p>（1）Object[] toArray()：返回包含当前集合中所有元素的数组</p>
<h2 id="二、Iterator迭代器"><a href="#二、Iterator迭代器" class="headerlink" title="二、Iterator迭代器"></a>二、Iterator迭代器</h2><p>主要用于遍历集合元素</p>
<p>Iterator iterator();&#x2F;&#x2F;Collection接口可以调用的方法，用于获取一个迭代器</p>
<h3 id="1-迭代器示例"><a href="#1-迭代器示例" class="headerlink" title="1.迭代器示例"></a>1.迭代器示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">c.add(<span class="number">11</span>);</span><br><span class="line">c.add(<span class="number">22</span>);</span><br><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断是否有下一个元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();<span class="comment">//获取下一个元素</span></span><br><span class="line">    sout(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、增强for"><a href="#三、增强for" class="headerlink" title="三、增强for"></a>三、增强for</h2><p>主要用于遍历数组和集合，注意不要在遍历的同时进行修改元素</p>
<h3 id="1-遍历数组"><a href="#1-遍历数组" class="headerlink" title="1.遍历数组"></a>1.遍历数组</h3><p>本质上还是普通for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">    sout(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-遍历集合"><a href="#2-遍历集合" class="headerlink" title="2.遍历集合"></a>2.遍历集合</h3><p>本质上是迭代器Iterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;efg&quot;</span>);</span><br><span class="line"><span class="comment">//增强for遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object  obj : c)&#123;</span><br><span class="line">    sout(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-增强for与Iterable接口"><a href="#3-增强for与Iterable接口" class="headerlink" title="3.增强for与Iterable接口"></a>3.增强for与Iterable接口</h3><p>实现了Iterable接口的类才可以使用增强for进行遍历，Collection接口是Iterable接口的子接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyArrayList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		MyArrayList&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String obj : my) &#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-快速失败机制"><a href="#4-快速失败机制" class="headerlink" title="4.快速失败机制"></a>4.快速失败机制</h3><p>使用迭代器在遍历集合时，如果使用迭代器之外的方法修改了集合的数据，会发生并发修改异常。因为这种操作会给数据带来不可预知的风险。为了防止后期发生更大问题，java采取这种机制，直接抛异常。这就是快速失败机制。实现方式借助集合中的一个成员变量modCount（用于统计集合中数据修改的次数）</p>
<h2 id="二、List集合"><a href="#二、List集合" class="headerlink" title="二、List集合"></a>二、List集合</h2><h3 id="1-List接口特点："><a href="#1-List接口特点：" class="headerlink" title="1. List接口特点："></a>1. List接口特点：</h3><p>​    List接口是Collection的子接口。List集合元素是有序的，可以重复的，并且是有索引的</p>
<h3 id="2-List接口常用方法"><a href="#2-List接口常用方法" class="headerlink" title="2.List接口常用方法"></a>2.List接口常用方法</h3><p>1、添加元素</p>
<ul>
<li>void add(int index, E ele)</li>
<li>boolean addAll(int index, Collection&lt;? extends E&gt; eles)</li>
</ul>
<p>2、获取元素</p>
<ul>
<li>E get(int index)</li>
<li>List subList(int fromIndex, int toIndex)</li>
</ul>
<p>3、获取元素索引</p>
<ul>
<li>int indexOf(Object obj)</li>
<li>int lastIndexOf(Object obj)</li>
</ul>
<p>4、删除和替换元素</p>
<ul>
<li>E remove(int index)</li>
<li>E set(int index, E ele)</li>
</ul>
<p>因为List集合的元素都有索引，索引还可以使用普通循环进行遍历集合。</p>
<h2 id="三、ArrayList实现类"><a href="#三、ArrayList实现类" class="headerlink" title="三、ArrayList实现类"></a>三、ArrayList实现类</h2><h3 id="1-底层结构"><a href="#1-底层结构" class="headerlink" title="1.底层结构"></a>1.底层结构</h3><p>底层结构是数组，查询快，增删慢，线程不安全的</p>
<p>区别：Vector实现类，底层结构也是数组，但是线程安全的，效率相对低，不再推荐使用</p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><ul>
<li><p>构造方法：<br>        new ArrayList（）：<br>                jdk6中，空参构造直接创建10长度的数组<br>                jdk7(新版)jdk8中，默认初始容量0，在添加第一元素时初始化容量为10<br>         new ArrayList(int initialCapacity):<br>                指定初始化容量</p>
</li>
<li><p>添加元素：add(E e);<br>    首次添加元素，初始化容量为10<br>    每次添加修改modCount属性值<br>    每次添加检查容量是否足够，容量不足时需要扩容，扩容大小为原容量的1.5倍</p>
</li>
<li><p>移除元素：remove(E e);<br>    每次成功移除元素，修改modCount值<br>    每次成功移除需要需要移动元素，以保证所以元素是连续存储的（删除操作效率低的原因）</p>
</li>
</ul>
<h3 id="3-Arrays工具类的asList方法"><a href="#3-Arrays工具类的asList方法" class="headerlink" title="3.Arrays工具类的asList方法"></a>3.Arrays工具类的asList方法</h3><p>​    通过此方法可以获取一个ArrayList集合，此集合是一个不可变的集合。不是java.util.ArrayList类.</p>
<h3 id="4-泛型初体验"><a href="#4-泛型初体验" class="headerlink" title="4.泛型初体验"></a>4.泛型初体验</h3><p>​    泛型通常用于集合中，用来在编译期限定集合中可以存储的元素类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="四、LinkedList实现类"><a href="#四、LinkedList实现类" class="headerlink" title="四、LinkedList实现类"></a>四、LinkedList实现类</h2><h3 id="1-特点和底层原"><a href="#1-特点和底层原" class="headerlink" title="1.特点和底层原"></a>1.特点和底层原</h3><p>底层结构是双向链表，查询效率低，增删效率高</p>
<p><img src="/JavaSE_IMGS%5C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="image-20201212083524290"></p>
<h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><ul>
<li>void  addFirst(Object obj )</li>
<li>void  addLast(Object obj )</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast ()</li>
</ul>
<h3 id="3-ListIterator"><a href="#3-ListIterator" class="headerlink" title="3.ListIterator"></a>3.ListIterator</h3><p>​    List集合特有的迭代器，是Iterator的子接口，拓展了更多功能。</p>
<ul>
<li>void add()：通过迭代器添加元素到对应集合</li>
<li>void set(Object obj)：通过迭代器替换正迭代的元素</li>
<li>void remove()：通过迭代器删除刚迭代的元素</li>
<li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li>
<li>Object previous()：返回列表中的前一个元素。</li>
<li>int previousIndex()：返回列表中的前一个元素的索引</li>
<li>boolean hasNext()</li>
<li>Object next()</li>
<li>int nextIndex()</li>
</ul>
<h2 id="五、Set集合"><a href="#五、Set集合" class="headerlink" title="五、Set集合"></a>五、Set集合</h2><p>特点：元素唯一，无序的</p>
<h3 id="1-HashSet实现类"><a href="#1-HashSet实现类" class="headerlink" title="1.HashSet实现类"></a>1.HashSet实现类</h3><ul>
<li>底层是一个HashMap实现，HashMap由Hash表实现</li>
<li>综合查询、增删性能高。</li>
</ul>
<h3 id="2-HashSet如何实现元素唯一？"><a href="#2-HashSet如何实现元素唯一？" class="headerlink" title="2.HashSet如何实现元素唯一？"></a>2.HashSet如何实现元素唯一？</h3><ul>
<li>存储元素时，先判断hashCode是否相同，如果相同再判断equals，如果都相同则认为是同一个元素，覆盖旧元素，实现唯一。</li>
<li>所以如果要添加元素到HashSet集合中，需要元素重写hashCode和equals方法。</li>
</ul>
<h3 id="3-LinkedHashSet实现类"><a href="#3-LinkedHashSet实现类" class="headerlink" title="3.LinkedHashSet实现类"></a>3.LinkedHashSet实现类</h3><ul>
<li>是HashSet的子类</li>
<li>底层是hash表基础上再维护一个链表，用于保证元素的迭代顺序</li>
</ul>
<h3 id="4-TreeSet实现类"><a href="#4-TreeSet实现类" class="headerlink" title="4.TreeSet实现类"></a>4.TreeSet实现类</h3><ul>
<li><p>底层结构是红黑树，是一种自动平衡的二叉树，查询效率高于链表</p>
</li>
<li><p>存储元素，小的放左子边，大的放右子树，遍历获取，采用中序遍历：左中右</p>
</li>
<li><p>元素实现了排序，如何实现唯一、排序？要求元素必须可以比较大小</p>
</li>
<li><p>默认TreeSet安装Comparable接口的方法比较元素或者使用Comparator接口的方法来比较元素</p>
<p><img src="/JavaSE_IMGS%5C%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20201212085410908"></p>
</li>
</ul>
<h2 id="六、Collection特点小结"><a href="#六、Collection特点小结" class="headerlink" title="六、Collection特点小结"></a>六、Collection特点小结</h2><p>Collection：集合根接口，存储一组对象。</p>
<ul>
<li>List：接口，特点是，元素可重复，有序（存取顺序一致）<ul>
<li>ArrayList：底层结构为数组，查询快，增删慢，线程不安全</li>
<li>LinkedList：底层结构为链表，查询慢，增删快</li>
<li>Vector：底层结构为数组，线程安全，效率低，不推荐使用</li>
</ul>
</li>
<li>Set：接口，特点是，元素唯一<ul>
<li>HashSet：底层结构为Hash表，查询和增删效率都高</li>
<li>TreeSet：底层结构为红黑树，查询效率高于链表，增删效率高于数组，元素实现排序</li>
<li>LinkedHashSet：底层结构为hash表+链表，链表保证元素的有序性</li>
</ul>
</li>
</ul>
<h2 id="七、Map集合"><a href="#七、Map集合" class="headerlink" title="七、Map集合"></a>七、Map集合</h2><h3 id="1-特点："><a href="#1-特点：" class="headerlink" title="1.特点："></a>1.特点：</h3><p>存储的是键值对。key是唯一的，无序的。</p>
<h3 id="2-常用方法-1"><a href="#2-常用方法-1" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><p>1、添加操作</p>
<ul>
<li>V put(K key,V value)</li>
<li>void putAll(Map&lt;? extends K,? extends V&gt; m)</li>
</ul>
<p>2、删除</p>
<ul>
<li>void clear()</li>
<li>V remove(Object key)</li>
</ul>
<p> 3、元素查询的操作</p>
<ul>
<li>V get(Object key)</li>
<li>boolean containsKey(Object key)</li>
<li>boolean containsValue(Object value)</li>
<li>boolean isEmpty()</li>
</ul>
<p> 4、元视图操作的方法：</p>
<ul>
<li>Set<K> keySet()</li>
<li>Collection<V> values()</li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</li>
</ul>
<p> 5、其他方法</p>
<ul>
<li>int size()</li>
</ul>
<h3 id="3-Map的遍历"><a href="#3-Map的遍历" class="headerlink" title="3.Map的遍历"></a>3.Map的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; keys = map.keySet();<span class="comment">//获取所有的key</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    sout(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//获取所有的键值对Entry</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="comment">//遍历所有的键值对Entry</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry : entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();<span class="comment">//得到key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();<span class="comment">//得到value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="八、Map接口实现类"><a href="#八、Map接口实现类" class="headerlink" title="八、Map接口实现类"></a>八、Map接口实现类</h2><h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><ul>
<li>底层结构：数组+链表+红黑树（JDK8之后）</li>
<li>特点：查询与存取效率较高，key和value都可以为null</li>
<li>底层原理：<ul>
<li>初始化容量：空参构造器，没有初始容量（第一次添加元素是初始化容量为16）</li>
<li>指定容量的构造器，初始化的容量值为大于指定的值的最小的2的n次幂。</li>
<li>添加元素时，如何确定元素在数组中的索引位置？①获取key的hashCode值②高低16的异或运算③跟数组长度取模运算，最后得到索引位置。</li>
<li>如何实现元素唯一？根据key的hashCode值比较和equals比较两个key，都相同则为相同元素，添加时覆盖旧的value</li>
<li>为什么引入红黑树？当链表长度较长时，查询效率降低，红黑树查询效率高于链表。</li>
<li>何时链表转为红黑树？链表长度达到8时，并且数组长度达到64时，转为红黑树。</li>
<li>何时扩容？①第一添加元素，扩容（初始化容量为16）②链表长度达到8时，并且数组长度未达到64时③元素个数达到扩容阈值（扩容阈值Threshold&#x3D;容量Capacity*加载因子0.75），扩容为原来容量的2倍。</li>
</ul>
</li>
</ul>
<h3 id="2-Hashtable类"><a href="#2-Hashtable类" class="headerlink" title="2.Hashtable类"></a>2.Hashtable类</h3><p>根据HashMap对比：底层结构同HashMap，线程安全，相对效率低，key和value不能为null</p>
<h3 id="3-LinkedHashMap类"><a href="#3-LinkedHashMap类" class="headerlink" title="3.LinkedHashMap类"></a>3.LinkedHashMap类</h3><p>是HashMap的子类，底层结构在哈希表基础上，又维护了一个链表，用于保证元素的迭代顺序</p>
<h4 id="4-TreeMap类"><a href="#4-TreeMap类" class="headerlink" title="4.TreeMap类"></a>4.TreeMap类</h4><p>底层结构是红黑树，一种自动平衡的二叉树，查询效率高于链表，增删效率高于数组</p>
<p>元素特点：实现了排序（元素必须可以比较大小，要么元素实现Comparable接口或者定义比较器用于比较要添加的元素）</p>
<p>new TreeMap()；&#x2F;&#x2F;添加元素时，要求元素必须实现Comparable接口</p>
<p>new TreeMap(Comparator c);&#x2F;&#x2F;添加元素时，可以使用传入的比较器参数来比较元素大小。</p>
<h3 id="5-Properties类"><a href="#5-Properties类" class="headerlink" title="5.Properties类"></a>5.Properties类</h3><p>是Hashtable的子类，通常存储的键值对都是String类型，并且不能为null。</p>
<p>String getProperty(String key);</p>
<h3 id="6-Set集合与Map集合的关系"><a href="#6-Set集合与Map集合的关系" class="headerlink" title="6.Set集合与Map集合的关系"></a>6.Set集合与Map集合的关系</h3><p>HashSet、LinkedHashSet和TreeSet底层都是借助对应的Map实现的。</p>
<h2 id="九、Collections工具类"><a href="#九、Collections工具类" class="headerlink" title="九、Collections工具类"></a>九、Collections工具类</h2><p>用于方便操作集合框架提供的工具类，里面都是静态方法。</p>
<ul>
<li>public static <T> boolean addAll(Collection&lt;? super T&gt; c,T… elements)将所有指定元素添加到指定 collection 中。</li>
<li>public static <T> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li>
<li>public static <T> int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li>
<li>public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</li>
<li>public static <T> T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</li>
<li>public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。</li>
<li>public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌</li>
<li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>public static <T> void sort(List<T> list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数</li>
<li>public static <T> void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中</li>
<li>public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值</li>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li>
<li>Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</li>
</ul>
<h1 id="第十一章-泛型"><a href="#第十一章-泛型" class="headerlink" title="第十一章 泛型"></a>第十一章 泛型</h1><h2 id="一、泛型理解"><a href="#一、泛型理解" class="headerlink" title="一、泛型理解"></a>一、泛型理解</h2><ol>
<li><p>泛型把运行期可能存在的安全隐患提前到编译器进行检查</p>
</li>
<li><p>不需要再运行期间，强制转换数据类型，来使用其特有方法</p>
</li>
<li><p>泛型相关术语</p>
<ol>
<li><strong>&lt;数据类型&gt;<strong>这种语法形式就叫</strong>泛型</strong>。其中数据类型只能是引用数据类型。<ul>
<li><code>TypeVariable</code>：类型变量，例如：<code>ArrayList&lt;E&gt;</code>中的E，<code>Map&lt;K,V&gt;</code>中的K,V</li>
<li><code>ParameterizedType</code>：参数化类型，例如：<code>Comparator&lt;T&gt;</code>，<code>Comparator&lt;String&gt;</code></li>
<li><code>GenericArrayType</code>：泛化的数组类型，即<code>T[]</code></li>
<li><code>WildcardType</code>：通配符类型，例如：<code>Comparator&lt;?&gt;</code>等</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="二、自定义泛型"><a href="#二、自定义泛型" class="headerlink" title="二、自定义泛型"></a>二、自定义泛型</h2><p>自定义的泛型变量可以用在类、接口和方法上:</p>
<ol>
<li><p>自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GerClass</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(T obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">show</span><span class="params">(T obj)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态成员不能使用泛型类上定义的泛型变量</span></span><br><span class="line">    <span class="comment">//private static  T t;//编译失败</span></span><br><span class="line">    <span class="comment">//public static test(T t)&#123;&#125;//不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GerInterface</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型接口情况一：实现类实现接口时明确了泛型变量的类型，实现类是一个普通的类，非泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">GerInterface</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String e)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型接口情况二：实现类实现接口时未明确了泛型变量的类型，实现类是一个泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">GerInterface</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义泛型方法</p>
<p>如果类或接口中只有一个方法要使用的类型不确定，类的其他成员用到的都是明确的数据类型，那么可以把此方法定义成泛型方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GerMethod</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>自定义泛型的使用注意事项</p>
<ol>
<li>明确的泛型类型必须是引用数据类型</li>
<li>使用泛型类创建对象，左右两边的明确的泛型参数类型必须一致</li>
<li>jdk只有，右边的泛型参数类型可以根据左边自动推断出来，可以省略右边的类型</li>
<li>如果明确泛型参数的类型，则默认为Object，称为泛型擦除</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//左右类型一致都是String</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//右边可以省略</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>()<span class="comment">//泛型擦除</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="三、通配符"><a href="#三、通配符" class="headerlink" title="三、通配符"></a>三、通配符</h2><ol>
<li><?>表示任意类型

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><? extends 上限数据类型> 表示设定了任意类型的上限。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();<span class="comment">//编译失败</span></span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line"><span class="comment">//设定了上限的list，适合用于消费数据，不适合添加数据</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//失败</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><? super 下限数据类型> 表示设定了任意类型的下限

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Animal&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();<span class="comment">//编译失败</span></span><br><span class="line"><span class="comment">//设定了下限的list，适合用于添加数据，不适合消费数据</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> list.get(<span class="number">0</span>);<span class="comment">//不方法使用元素的特有功能，而且如有要强制转换可能有类型转换异常</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第12章-File类和IO流"><a href="#第12章-File类和IO流" class="headerlink" title="第12章 File类和IO流"></a>第12章 File类和IO流</h1><h2 id="一、File类"><a href="#一、File类" class="headerlink" title="一、File类"></a>一、File类</h2><ol>
<li><p>Java提供了java.io.File类，用于抽象的描述系统中的文件或目录，这个类的对象封装了文件或目录的相关信息。</p>
</li>
<li><p>构造方法</p>
<ul>
<li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li>
<li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public long lastModified()</code>：返回File对象对应的文件或目录的最后修改时间（毫秒值）</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>String getCanonicalPath()</code>：返回此File对象所对应的规范路径名。</p>
</li>
<li><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</p>
</li>
<li><p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</p>
</li>
<li><p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
</li>
<li><p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p>
</li>
<li><p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  只能删除空目录。</p>
</li>
<li><p><code>public boolean mkdir()</code> ：创建由此File表示的目录。</p>
</li>
<li><p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</p>
</li>
<li><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="二、IO流概述"><a href="#二、IO流概述" class="headerlink" title="二、IO流概述"></a>二、IO流概述</h2><ol>
<li><p>把数据从一种介质中传输到另外一种介质中，称为数据传输，我们可以看成数据的流动，如何把数据进行传输，java提供了各种流对象并提供相应的方法，实现数据的传输。</p>
</li>
<li><p>IO分类：</p>
<ol>
<li><p>安照数据流动方向划分（参照物为内存）：输入流和输出流</p>
</li>
<li><p>按照数据单位划分：字节流和字符流</p>
<p>InputStream字节输入流的超类</p>
<p>OutputStream字节输出流的超类</p>
<p>Reader字符输入流的超类</p>
<p>Writer字符输出流的超类</p>
</li>
</ol>
</li>
</ol>
<h2 id="三、字节流"><a href="#三、字节流" class="headerlink" title="三、字节流"></a>三、字节流</h2><p>InputStream字节输入流的超类</p>
<p>OutputStream字节输出流的超类</p>
<ol>
<li><p>FileInputStream实现类，可以读取文件中的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个文件字节输入流，用于读取文件中的数据到内存中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa.java&quot;</span>);</span><br><span class="line"><span class="comment">//2.读取数据</span></span><br><span class="line"><span class="comment">//读取一个字节,如果读取到-1表示没有数据了</span></span><br><span class="line"><span class="comment">/* int read = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println((char)read);</span></span><br><span class="line"><span class="comment">        read = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println((char)read);</span></span><br><span class="line"><span class="comment">        read = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(read);</span></span><br><span class="line"><span class="comment">        read = fis.read();</span></span><br><span class="line"><span class="comment">        System.out.println(read);*/</span></span><br><span class="line"><span class="comment">//循环读一个字节</span></span><br><span class="line"><span class="comment">/* int ch=-1;</span></span><br><span class="line"><span class="comment">       while ((ch=fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">           System.out.println((char) ch);//打印到控制台</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line"><span class="comment">//读取一个字节数组</span></span><br><span class="line"><span class="comment">/*   byte[] bys = new byte[4];</span></span><br><span class="line"><span class="comment">        int len = fis.read(bys);//把数据读取到字节数组中，并且返回读取的字节数</span></span><br><span class="line"><span class="comment">        System.out.println(len);</span></span><br><span class="line"><span class="comment">        System.out.println(new String(bys,0,len));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        len = fis.read(bys);</span></span><br><span class="line"><span class="comment">        System.out.println(len);</span></span><br><span class="line"><span class="comment">        System.out.println(new String(bys,0,len));*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环读取一个字节数组</span></span><br><span class="line"><span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bys))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bys, <span class="number">0</span>, len));<span class="comment">//控制台输出读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileOutputStream实现类，用于把数据写入到文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个文件字节输出流对象</span></span><br><span class="line"><span class="comment">//        FileOutputStream fos = new FileOutputStream(new File(&quot;D:/test/fos1.txt&quot;));</span></span><br><span class="line"><span class="comment">//        FileOutputStream fos = new FileOutputStream(&quot;D:/test/fos1.txt&quot;);</span></span><br><span class="line"><span class="comment">//        FileOutputStream fos = new FileOutputStream(&quot;D:/test/fos1.txt&quot;, true);//第二个参数true表示追加写入</span></span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos1.txt&quot;</span>);<span class="comment">//相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写出数据</span></span><br><span class="line"><span class="comment">//写一个字节</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line"><span class="comment">//写一个字节数组</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;world&quot;</span>.getBytes();</span><br><span class="line">fos.write(bytes);</span><br><span class="line"><span class="comment">//写入字节数组的一部分:第二个参数起始索引，第三个参数字节数</span></span><br><span class="line">fos.write(bytes, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//写入换行</span></span><br><span class="line">fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">fos.write(<span class="number">98</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="四、字符流"><a href="#四、字符流" class="headerlink" title="四、字符流"></a>四、字符流</h2><p>Reader字符输入流的超类</p>
<p>Writer字符输出流的超类</p>
<ol>
<li>FileReader实现类用于按照字符读取文件文本文件中的数据</li>
<li>FileWriter实现类用于按照字符把数据写入到文本文件中</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//复制文件一次读写一个字符</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一个文本字符输入流，用于读取一个文本文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;aaa.java&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个文本字符输出流，用于把字符数据写入到一个文件中</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写数据，一次读写一个字符</span></span><br><span class="line">        <span class="type">int</span> ch=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)&#123;<span class="comment">//从文件读取一个字符</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写入一个字符到文件</span></span><br><span class="line"><span class="comment">//            fw.flush();//根据需求使用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//复制文件一次读写一个字符</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一个文本字符输入流，用于读取一个文本文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;aaa.java&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个文本字符输出流，用于把字符数据写入到一个文件中</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写数据，一次读写一个字符</span></span><br><span class="line">        <span class="type">int</span> ch=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)&#123;<span class="comment">//从文件读取一个字符</span></span><br><span class="line">            fw.write(ch);<span class="comment">//写入一个字符到文件</span></span><br><span class="line"><span class="comment">//            fw.flush();//根据需求使用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。字符流默认缓冲区为8k的字符数组。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<h2 id="五、缓冲流"><a href="#五、缓冲流" class="headerlink" title="五、缓冲流"></a>五、缓冲流</h2><p>缓冲流,也叫高效流，按照数据类型分类：</p>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小为8k的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<ul>
<li><strong>字节缓冲流</strong>：<ul>
<li><code>BufferedInputStream</code>，<ul>
<li>new BufferedInputStream(new FileInputStream(“bis.txt”));</li>
<li>int read();</li>
<li>int read(byte[] arr);</li>
</ul>
</li>
<li><code>BufferedOutputStream</code> <ul>
<li>new BufferedOutputStream(new FileOutputStream(“bos.txt”));</li>
<li>write(int ch);</li>
<li>write(byte[] arr,int offset,int count);</li>
</ul>
</li>
</ul>
</li>
<li><strong>字符缓冲流</strong>：<ul>
<li><code>BufferedReader</code>，<ul>
<li>new BufferedReader(new FileReader(“br.txt”));</li>
<li>int read();</li>
<li>int read(char[] arr);</li>
<li>String readLine();&#x2F;&#x2F;读取一行字符串</li>
</ul>
</li>
<li><code>BufferedWriter</code><ul>
<li>new BufferedWriter(new FileWriter(“bw.txt”));</li>
<li>write(int ch);</li>
<li>write(char[] arr,int offset,int count);</li>
<li>write(String s);&#x2F;&#x2F;写一个字符串</li>
<li>newLine();&#x2F;&#x2F;写一个换行符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="六、转换流"><a href="#六、转换流" class="headerlink" title="六、转换流"></a>六、转换流</h2><p>转换流属于字符流，可以把字节转换成字符，或者把字符转换成字节。可以读取、写入指定编码格式的文本</p>
<p>转换流&#x3D;字节流+编码</p>
<ul>
<li>InputStreamReader<ul>
<li>构造器示例：new InputStreamReader(new FileInputStream(“isr.txt”),”GBK”);</li>
<li>对比：new FileReader(“fr.txt”);&#x2F;&#x2F;使用平台默认编码</li>
</ul>
</li>
<li>OutputStreamWriter<ul>
<li>构造器示例：new OutputStreamWriter(new FileOutputStream(“osr.txt”),”UTF-8”);</li>
<li>对比：new FileWriter(“fw.txt”);&#x2F;&#x2F;使用平台默认编码</li>
</ul>
</li>
</ul>
<h2 id="七、对象流"><a href="#七、对象流" class="headerlink" title="七、对象流"></a>七、对象流</h2><h3 id="1-序列化与反序列化"><a href="#1-序列化与反序列化" class="headerlink" title="1.序列化与反序列化"></a>1.序列化与反序列化</h3><ul>
<li>序列化：把Java对象转换成字节序列，通常为了保存到文件中或在网络中传输，需要序列化</li>
<li>反序列化：把描述对象的字节序列，转换为Java对象，就是反序列化</li>
<li><strong>transient关键字</strong>修饰的属性，表示不会被序列化</li>
</ul>
<h3 id="2-ObjectOutputStream和ObjectInputStream"><a href="#2-ObjectOutputStream和ObjectInputStream" class="headerlink" title="2.ObjectOutputStream和ObjectInputStream"></a>2.ObjectOutputStream和ObjectInputStream</h3><p>ObjectOutputStream用于把Java对象，写入到其它介质中，持久化存储。</p>
<p>要求被写入的Java类必须实现Serializable接口，表示此类的对象可以被序列化。</p>
<ul>
<li>new ObjectOutputStream(new FileOutputStream(“oos.txt”));</li>
<li>writeObject(Object obj);</li>
</ul>
<p>ObjectInputStream用于读取其它介质中存储的Java对象到内存中</p>
<ul>
<li>new ObjectInputStream(new FileInputStream(“oos.txt”));</li>
<li>Object readObject();</li>
</ul>
<p>注意的问题：</p>
<ul>
<li><p>写入对象使用的类与读取对象使用的类必须是同一个类。如何确定是否同一个类，默认实现了序列化接口的这个类会自动生成一个用表示类的版本信息的属性<code>serialVersionUID</code>  ，</p>
<ul>
<li>&#96;&#96;&#96;java<br> private static final long serialVersionUID &#x3D; 1L;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 八、打印流与标准输入输出流</span><br><span class="line"></span><br><span class="line">### 1.打印流</span><br><span class="line"></span><br><span class="line">打印流只有输出，没有对应的输入流</span><br><span class="line"></span><br><span class="line">- PrintStream字节打印流</span><br><span class="line"></span><br><span class="line">  - `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的字节打印流。</span><br><span class="line">  - print(Object obj);</span><br><span class="line">  - println();//打印换行</span><br><span class="line"></span><br><span class="line">- PrintWriter字符打印流</span><br><span class="line"></span><br><span class="line">  - `public PrintWriter(String fileName)` ：使用指定的文件名创建一个新的字符打印流。</span><br><span class="line">  - `PrintWriter(OutputStream out,  boolean autoFlush)` ：基于字符输出流创建一个自动刷新的字符打印流</span><br><span class="line"></span><br><span class="line">  ### 2.标准输入输出流</span><br><span class="line"></span><br><span class="line">  | Modifier and Type    | Field and Description                             |</span><br><span class="line">  | -------------------- | ------------------------------------------------- |</span><br><span class="line">  | `static PrintStream` | `err`  The &quot;standard&quot; error output stream.        |</span><br><span class="line">  | `static InputStream` | `in`  The &quot;standard&quot; input stream. 从键盘接收数据 |</span><br><span class="line">  | `static PrintStream` | `out`  The &quot;standard&quot; output stream.输出到控制台  |</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ## 九、JDK7后try...catch</span><br><span class="line"></span><br><span class="line">  语法格式：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  try(需要关闭的资源对象的声明)&#123;</span><br><span class="line">      业务逻辑代码</span><br><span class="line">  &#125;catch(异常类型 e)&#123;</span><br><span class="line">      处理异常代码</span><br><span class="line">  &#125;catch(异常类型 e)&#123;</span><br><span class="line">      处理异常代码</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure></li>
</ul>
<p>它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p>
</li>
</ul>
<h1 id="第14章-网络编程"><a href="#第14章-网络编程" class="headerlink" title="第14章 网络编程"></a>第14章 网络编程</h1><h2 id="一、BS与CS架构区别"><a href="#一、BS与CS架构区别" class="headerlink" title="一、BS与CS架构区别"></a>一、BS与CS架构区别</h2><ul>
<li>BS架构:Browser&#x2F;Server<ul>
<li>只需要开发服务端，不需要开发客户端,用户不需要下载客户端</li>
<li>多网络带宽要求高</li>
<li>数据安全性相对差</li>
</ul>
</li>
<li>CS架构:Client&#x2F;Server<ul>
<li>需要开发客户端和服务端，用户使用时需要下载更新客户端</li>
<li>对网络带宽要求相对低</li>
<li>数据安全好</li>
<li>对于软件的渲染效果更好，比如大型游戏等</li>
</ul>
</li>
</ul>
<h2 id="二、网络编程三要素"><a href="#二、网络编程三要素" class="headerlink" title="二、网络编程三要素"></a>二、网络编程三要素</h2><ol>
<li><p>协议：规定了网络中的数据如何传输，以及传输方式等内容</p>
</li>
<li><p>ip：网络中每台计算机的唯一标识</p>
</li>
<li><p>端口：计算机中每个运行的程序的唯一标识（0~65535）</p>
</li>
</ol>
<h2 id="三、UDP与TCP协议"><a href="#三、UDP与TCP协议" class="headerlink" title="三、UDP与TCP协议"></a>三、UDP与TCP协议</h2><ol>
<li><p>UDP协议：（发短信）</p>
<ol>
<li>面向无连接的，</li>
<li>安全性差</li>
<li>效率高</li>
<li>一次传输的数据量有限</li>
</ol>
</li>
<li><p>TCP协议：（打电话）</p>
<ol>
<li>面向连接的（三次握手、四次挥手）</li>
<li>数据安全性高</li>
<li>效率低</li>
<li>理论上建立一次连接后传输的数据量无限制</li>
</ol>
</li>
</ol>
<h2 id="四、TCP与UDP编程"><a href="#四、TCP与UDP编程" class="headerlink" title="四、TCP与UDP编程"></a>四、TCP与UDP编程</h2><h3 id="1-TCP编程"><a href="#1-TCP编程" class="headerlink" title="1.TCP编程"></a>1.TCP编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建Socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.17.69&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">        <span class="comment">//通过socket获取一个输输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        os.write(<span class="string">&quot;hello tcp&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个ServerSocket对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获取一个socket对象</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();<span class="comment">//是一个阻塞方法</span></span><br><span class="line">            <span class="comment">//获取对方ip对象</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> s.getInetAddress();</span><br><span class="line">            <span class="comment">//获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="comment">//取出数据</span></span><br><span class="line">            <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bys);</span><br><span class="line">            System.out.println(ip.getHostAddress()+<span class="string">&quot;:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bys, <span class="number">0</span>, len));<span class="comment">//控制台输出内容</span></span><br><span class="line">            s.close();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        //释放资源</span></span><br><span class="line"><span class="comment">////        s.close();</span></span><br><span class="line"><span class="comment">////        ss.close();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-UDP编程"><a href="#2-UDP编程" class="headerlink" title="2.UDP编程"></a>2.UDP编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建Socket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//创建数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="string">&quot;hello udp&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.17.69&quot;</span>);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,ip,<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;udp接收端启动了...&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Socket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//创建一个数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,<span class="number">0</span>,bys.length);</span><br><span class="line">        <span class="comment">//接收数据包,把数据接收到数据包中</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line">        <span class="comment">//从数据包中解析出数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line">        <span class="comment">//控制台输出数据</span></span><br><span class="line">        System.out.println(ip.getHostAddress()+<span class="string">&quot;:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="第13章多线程"><a href="#第13章多线程" class="headerlink" title="第13章多线程"></a>第13章多线程</h1><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><ol>
<li><p>并行与并发</p>
<ul>
<li>并行：同一个时刻内（时间点），同时发生多个事件。单核cpu不支持并行</li>
<li>并发：同一个微小的时间段内，同时发生了多个事件。</li>
</ul>
</li>
<li><p>线程与进程</p>
<ul>
<li>进程：进程是程序运行过程的描述，系统为每个进程分配独立的系统资源。</li>
<li>线程：线程是每个进程中最小的一个执行单元，每个进程中至少有一个线程，也可以有多个线程，这时就是多线程程序。Java支持多线程。</li>
</ul>
</li>
<li><p>多线程的优点与应用场景：</p>
<ul>
<li>充分利用CPU资源，提示程序的响应速度</li>
<li>多个线程执行相同任务，来完成一个大的任务，比如多线程下载文件。</li>
<li>多个线程执行不同任务，来完成一个的任务，比如，录屏软件，录桌面图像的同时还在录制声音</li>
</ul>
</li>
<li><p>线程调度</p>
<ul>
<li>分时调度：CPU平均分派时间来，执行不同的线程</li>
<li>抢占式调度：CPU随机执行某一个线程，Java使用的是抢占式调度方式</li>
</ul>
</li>
</ol>
<h2 id="二、线程的创建与启动方式"><a href="#二、线程的创建与启动方式" class="headerlink" title="二、线程的创建与启动方式"></a>二、线程的创建与启动方式</h2><ol>
<li>方式一：继承Thread类<ol>
<li>定一个类继承Thread类，并重写run方法，这个子类就是一个线程类</li>
<li>创建这个线程类的对象</li>
<li>调用start方法启动线程</li>
</ol>
</li>
<li>方式二：实现Runnable接口<ol>
<li>定一个类实现Runnable接口，重写run方法，这个实现类是个线程任务类</li>
<li>创建线程任务类对象</li>
<li>通过Thread类创建线程对象，并通过构造器传入线程任务类对象</li>
<li>调用线程的start方法启动线程</li>
</ol>
</li>
<li>两种方式的比较<ul>
<li>方式一：有单继承的限制，使用简单</li>
<li>方式二：没有单继承限制，使用稍微复杂，方便共享数据</li>
</ul>
</li>
<li>匿名内部类方式创建线程</li>
</ol>
<h2 id="三、Thread类及常用方法"><a href="#三、Thread类及常用方法" class="headerlink" title="三、Thread类及常用方法"></a>三、Thread类及常用方法</h2><ol>
<li><strong>构造方法</strong></li>
</ol>
<ul>
<li>public Thread() :分配一个新的线程对象。</li>
<li>public Thread(String name) :分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</li>
<li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<ol start="2">
<li><strong>线程使用基础方法</strong></li>
</ol>
<ul>
<li>public void run() :此线程要执行的任务在此处定义代码。</li>
<li>public String getName() :获取当前线程名称。</li>
<li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</li>
<li>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </li>
<li>public final int getPriority() ：返回线程优先级 </li>
<li>public final void setPriority(int newPriority) ：改变线程的优先级</li>
</ul>
<ol start="3">
<li><strong>线程控制相关方法</strong></li>
</ol>
<ul>
<li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p>
</li>
<li><p>public static void sleep(long millis) :线程睡眠，使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p>
</li>
<li><p>public static void yield()：线程礼让，yield只是让当前线程暂时失去执行权，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</p>
</li>
<li><p>void join() ：加入线程，当前线程中加入一个新线程，等待加入的线程终止后再继续执行当前线程。 </p>
<p>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p>
<p>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p>
</li>
<li><p>public final void stop()：强迫线程停止执行。 该方法具有不安全性，已被弃用，最好不要使用。</p>
<ul>
<li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li>
<li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li>
</ul>
</li>
<li><p>public void interrupt()：中断线程，实际上是给线程打上一个中断的标记，并不会真正使线程停止执行。</p>
</li>
<li><p>public static boolean interrupted()：检查线程的中断状态，调用此方法会清除中断状态（标记）。</p>
</li>
<li><p>public boolean isInterrupted()：检查线程中断状态，不会清除中断状态（标记）</p>
</li>
<li><p>public void setDaemon(boolean on)：将线程设置为守护线程或用户线程。必须在线程启动之前设置，否则会报<code>IllegalThreadStateException</code>异常。</p>
<ul>
<li><strong>守护线程</strong>，主要为其他线程服务，当程序中没有非守护线程执行时，守护线程也将终止执行。JVM垃圾回收器也是守护线程。</li>
</ul>
</li>
<li><p>public boolean isDaemon()：检查当前线程是否为守护线程。</p>
</li>
</ul>
<h2 id="四、线程的生命周期"><a href="#四、线程的生命周期" class="headerlink" title="四、线程的生命周期"></a>四、线程的生命周期</h2><p><img src="/JavaSE_IMGS%5C%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81.png" alt="image-20201218085714635"></p>
<h2 id="五、线程安全问题"><a href="#五、线程安全问题" class="headerlink" title="五、线程安全问题"></a>五、线程安全问题</h2><ol>
<li><p>线程安全问题的原因（条件）</p>
<ul>
<li>共享数据</li>
<li>多个线程</li>
<li>多个条语句操作共享资源</li>
</ul>
</li>
<li><p>线程安全问题的解决</p>
<ul>
<li>把多条操作共享资源的代码，捆绑成一个整体来执行，同步执行这些代码，当一个线程在执行这些代码时，其他线程不允许执行。</li>
<li>Java使用关键字synchronized实现同步机制</li>
</ul>
</li>
<li><p>同步机制</p>
<ul>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//会产生线程安全问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;<span class="comment">//</span></span><br><span class="line">     <span class="comment">//需要同步操作的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同步锁对象，可以是任意的Java对象</p>
<ol>
<li>多个线程需要使用同一个锁对象</li>
<li>同步代码块中，通常使用this或者当前类的Class对象</li>
<li>同步静态方法，默认锁对象为当前类的Class对象</li>
<li>同步非静态方法，默认锁对象是this</li>
</ol>
</li>
<li><p>单例模式中懒汉式的线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton ourInstance=<span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//获取单例的公共静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//一旦创建了对象，之后再次获取对象，都不会再进入同步代码块，提升效率</span></span><br><span class="line">        <span class="keyword">if</span> (ourInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//同步锁，锁住判断语句与创建对象并赋值的语句</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ourInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ourInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="六、线程间通信"><a href="#六、线程间通信" class="headerlink" title="六、线程间通信"></a>六、线程间通信</h2><ol>
<li>线程间通信：指的是一个线程执行需要根据另外一个线程的执行结果来执行，从而做到线程之间进行沟通交流。</li>
<li>生产者与消费者问题：<ul>
<li>生成者线程的生成出商品后，需要等待，并通知消费者线程来消费</li>
<li>消费者线程消费完商品后，需要等待，并通知生产者线程来生产商品。</li>
</ul>
</li>
<li>等待唤醒机制可以实现以通信机制</li>
</ol>
<h2 id="七、死锁问题"><a href="#七、死锁问题" class="headerlink" title="七、死锁问题"></a>七、死锁问题</h2><p>当多个线程使用同步机制不当时，比如相同嵌套使用同步代码块，并且使用不同的同步锁，可能会导致死锁。一个线程需要的同步锁被另外一个线程使用无法释放，反之亦然，从而导致死锁。</p>
<h1 id="第十五章-反射"><a href="#第十五章-反射" class="headerlink" title="第十五章 反射"></a>第十五章 反射</h1><h2 id="一、类的加载"><a href="#一、类的加载" class="headerlink" title="一、类的加载"></a>一、类的加载</h2><h3 id="1、类的加载过程：只执行一次"><a href="#1、类的加载过程：只执行一次" class="headerlink" title="1、类的加载过程：只执行一次"></a>1、类的加载过程：只执行一次</h3><ul>
<li><p>加载：把字节码文件加载到内存中</p>
</li>
<li><p>链接</p>
<ul>
<li>验证：语义分析，语法分析，保证JVM的安全</li>
<li>准备：为静态变量赋予默认初始值；给静态常量直接显示赋值</li>
<li>解析：把符号引用转换为实际的内地址引用等</li>
</ul>
</li>
<li><p>初始化：执行以下两部分代码，通常给静态变量赋值。</p>
<ul>
<li><p>静态遍历的直接显示赋值代码</p>
</li>
<li><p>静态代码块中的代码</p>
</li>
</ul>
</li>
</ul>
<h3 id="2、导致类的初始化的操作"><a href="#2、导致类的初始化的操作" class="headerlink" title="2、导致类的初始化的操作"></a>2、导致类的初始化的操作</h3><ul>
<li><p>运行主方法所在的类，要先完成类初始化，再执行main方法</p>
</li>
<li><p>第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p>
</li>
<li><p>调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p>
</li>
<li><p>子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p>
</li>
<li><p>通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p>
</li>
</ul>
<h3 id="3、不会导致类初始化的操作"><a href="#3、不会导致类初始化的操作" class="headerlink" title="3、不会导致类初始化的操作"></a>3、不会导致类初始化的操作</h3><ul>
<li><p>使用某个类的静态的常量（static  final）</p>
</li>
<li><p>通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p>
</li>
<li><p>用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p>
</li>
<li><p>用某个类型声明变量</p>
</li>
</ul>
<h3 id="4、类加载器"><a href="#4、类加载器" class="headerlink" title="4、类加载器"></a>4、类加载器</h3><p>一个Java类是通过类加载器加载到内存中，不同的类加载器加载特定目录下的类</p>
<ol>
<li>启动类加载器Bootstrap ClassLoader<ul>
<li>主要加载jre&#x2F;lib目录下的java程序要正常运行需要的类，比如rt.jar</li>
<li>一般由其他语言编写，比如C++</li>
</ul>
</li>
<li>扩展类加载器 Ext ClassLoader<ul>
<li>加载jre&#x2F;lib&#x2F;ext目录下的jar</li>
<li>由Java编写的</li>
</ul>
</li>
<li>应用程序类加载器 App ClassLoader<ul>
<li>主要加载classpath下的类</li>
<li>由Java编写的</li>
</ul>
</li>
<li>自定义类加载器<ul>
<li>加载指定目录的类</li>
<li>java编写，需要继承自ClassLoader</li>
</ul>
</li>
</ol>
<h3 id="5、双亲委派机制"><a href="#5、双亲委派机制" class="headerlink" title="5、双亲委派机制"></a>5、双亲委派机制</h3><p>当一个类加载器接收到一个类的加载请求时，此类加载器会先请求父类类加载来加载这个类，如果加载成功就结束。否则，会询问启动类加载器是否加载过这个类，加载过则结束，否则自己来加载这个类，不成功则报异常ClassNotFoundException</p>
<p>这样做的目的主要是为了保证一个类只加载一次到内存中</p>
<p>一个类加载成功后的产物：这个类的Class类对象</p>
<h2 id="二、Class类"><a href="#二、Class类" class="headerlink" title="二、Class类"></a>二、Class类</h2><p>万物皆对象，每个类编译后生成的字节码文件，即class文件，在类加载后JVM会为每个class文件创建一个对象，也就是Class类的一个对象。这个Class对象封装了类在方法区内的数据信息，并且向Java程序员提供了访问方法区内的类数据信息的接口。</p>
<p>类的Class对象是反射的根源。</p>
<h3 id="获取类的Class对象的方式"><a href="#获取类的Class对象的方式" class="headerlink" title="获取类的Class对象的方式"></a>获取类的Class对象的方式</h3><ul>
<li>类名.class</li>
<li>对象.getClass();  &#x2F;&#x2F;来自Object类的方法</li>
<li>Class.forName(“java.util.ArrayList”);  &#x2F;&#x2F;Class类的静态方法</li>
<li>类加载器的loadClass(“类的全路径”);</li>
</ul>
<h2 id="三、反射"><a href="#三、反射" class="headerlink" title="三、反射"></a>三、反射</h2><p><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>
<p>反射可以获取类的任意信息，包括修饰符、类名、接口名、类的成员变量，方法、构造器、泛型、注解等。详细查询API</p>
<h1 id="第十六章-JDK8新特性"><a href="#第十六章-JDK8新特性" class="headerlink" title="第十六章 JDK8新特性"></a>第十六章 JDK8新特性</h1><h2 id="一、lambda表达式"><a href="#一、lambda表达式" class="headerlink" title="一、lambda表达式"></a>一、lambda表达式</h2><h3 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1.函数式接口"></a>1.函数式接口</h3><ul>
<li>只有一个抽象方法的接口，SAM</li>
<li>可以使用注解@FunctionalInterface 来验证是否是函数式接口</li>
</ul>
<h3 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h3><ul>
<li>SAM接口的语法糖</li>
<li>本质是匿名内部类对象</li>
</ul>
<h3 id="3-Lambda表达式语法"><a href="#3-Lambda表达式语法" class="headerlink" title="3.Lambda表达式语法"></a>3.Lambda表达式语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;Lambda体&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>(形参列表)它就是你要赋值的函数式接口的抽象方法的(形参列表)，照抄</li>
<li>{Lambda体}就是实现这个抽象方法的方法体</li>
<li>-&gt;称为Lambda操作符（减号和大于号中间不能有空格，而且必须是英文状态下半角输入方式）</li>
</ul>
<p>优化：Lambda表达式可以精简</p>
<ul>
<li>当{Lambda体}中只有一句语句时，可以省略{}和{;}</li>
<li>当{Lambda体}中只有一句语句时，并且这个语句还是一个return语句，那么return也可以省略，但是如果{;}没有省略的话，return是不能省略的</li>
<li>(形参列表)的类型可以省略</li>
<li>当(形参列表)的形参个数只有一个，那么可以把数据类型和()一起省略，但是形参名不能省略</li>
<li>当(形参列表)是空参时，()不能省略</li>
</ul>
<h3 id="4-方法引用和构造器引用"><a href="#4-方法引用和构造器引用" class="headerlink" title="4. 方法引用和构造器引用"></a>4. 方法引用和构造器引用</h3><ul>
<li><p>方法引用：在特定条件下对lambda表达式的简化</p>
</li>
<li><p>特定条件：lambda体只有一条语句，并且lambda体中在一个方法中使用了全部的参数</p>
</li>
<li><p>方法引用的语法格式：</p>
<p>（1）实例对象名::实例方法        </p>
<p>（2）类名::静态方法</p>
<p>（3）类名::实例方法</p>
</li>
<li><p>构造器引用：lambda体正好是创建一个对象或对象数组时，可以简化</p>
</li>
<li><p>构造器引用的语法格式：</p>
<ul>
<li>类名::new</li>
<li>数组类型名::new</li>
</ul>
</li>
</ul>
<h2 id="二、Stream"><a href="#二、Stream" class="headerlink" title="二、Stream"></a>二、Stream</h2><p>Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，负责存储数据，Stream流讲的是计算，负责处理数据！”</p>
<ul>
<li><p>特点：</p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
</li>
<li><p>Stream 的操作三个步骤：</p>
<ol>
<li>创建 Stream：通过一个数据源（如：集合、数组），获取一个流</li>
<li>中间操作：中间操作是个操作链，对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</li>
<li>终止操作：一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</li>
</ol>
</li>
</ul>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><table>
<thead>
<tr>
<th><strong>方  法</strong></th>
<th><strong>描  述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>filter(Predicate p)</strong></td>
<td>接收 Lambda ， 从流中排除某些元素，保留符合条件的元素</td>
</tr>
<tr>
<td><strong>distinct()</strong></td>
<td>筛选，通过流所生成元素的equals() 去除重复元素</td>
</tr>
<tr>
<td><strong>limit(long maxSize)</strong></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><strong>skip(long n)</strong></td>
<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
<tr>
<td><strong>peek(Consumer</strong> <strong>action)</strong></td>
<td>接收Lambda，对流中的每个数据执行Lambda体操作</td>
</tr>
<tr>
<td><strong>sorted()</strong></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><strong>sorted(Comparator com)</strong></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
<tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td><strong>mapToInt(ToIntFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td><strong>mapToLong(ToLongFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean</strong> <strong>allMatch(Predicate p)</strong></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td><strong>boolean</strong> <strong>anyMatch</strong>(<strong>Predicate p</strong>)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><strong>boolean</strong> <strong>noneMatch(Predicate  p)</strong></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><strong>Optional<T></strong> <strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>Optional<T></strong> <strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>long</strong> <strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>Optional<T></strong> <strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>Optional<T></strong> <strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>void</strong> <strong>forEach(Consumer c)</strong></td>
<td>迭代</td>
</tr>
<tr>
<td><strong>T</strong> <strong>reduce(T iden, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 T</td>
</tr>
<tr>
<td><strong>U</strong> <strong>reduce(BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
<tr>
<td><strong>R</strong> <strong>collect(Collector c)</strong></td>
<td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<h2 id="三、Optional"><a href="#三、Optional" class="headerlink" title="三、Optional"></a>三、Optional</h2><p>Optional是一个容器，可以存储一个对象。用于处理空指针异常而设计的一个容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCity2</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">    <span class="comment">//Optional存储一个可以为null对象</span></span><br><span class="line">    <span class="comment">//        Optional&lt;Person&gt; optional =Optional.ofNullable(person);</span></span><br><span class="line">    <span class="comment">//        Optional&lt;Address&gt; address = optional.map(p -&gt; p.getAddress());//这里p.getAddress不会空指针异常</span></span><br><span class="line">    <span class="comment">//        Optional&lt;String&gt; city = address.map(addr -&gt; addr.getCity());//这里addr.getCity不会空指针异常</span></span><br><span class="line">    <span class="comment">//        String msg = city.orElse(&quot;无城市信息&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(person).map(Person::getAddress).map(Address::getCity).orElse(<span class="string">&quot;无信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://peihaiyang.github.io/2022/03/07/JavaSE%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/03/07/String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            (no title)
          
        </div>
      </a>
    
    
      <a href="/2022/03/07/Spring/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title"></div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> PHY
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="红尘泪思颜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>